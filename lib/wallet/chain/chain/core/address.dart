part of 'package:on_chain_wallet/wallet/chain/chain/chain.dart';

typedef _ONUUPDATETOKENBALANCE = bool Function();

enum IAdressType {
  /// Simple address
  singleKey,

  /// multisig address thats work with main account. like tron and ripple
  multisigByAddress,

  /// multisig address. address generated by multiple public key like bitcoin, aptos, sui and ..
  multisigByPublicKey;

  bool get isMultisig => this != singleKey;

  bool get isMultisigByPublicKey => this == IAdressType.multisigByPublicKey;
}

abstract class MultiSigCryptoAccountAddress {}

typedef NETWORKCHAINACCOUNT<NETWORKADDRESS>
    = ChainAccount<NETWORKADDRESS, TokenCore, NFTCore, ChainTransaction>;
typedef NFTCHAINACCOUNT<NFT extends NFTCore>
    = ChainAccount<dynamic, TokenCore, NFT, ChainTransaction>;

class ChainAccountBalance {
  ChainAccountBalance({
    required this.address,
    BigInt? balance,
    required WalletNetwork network,
    DateTime? updated,
  })  : _updated = updated ?? DateTime.now(),
        balance = InternalStreamValue.immutable(IntegerBalance.token(
            balance ?? BigInt.zero, network.token,
            immutable: true));

  factory ChainAccountBalance.deserialize(WalletNetwork network,
      {List<int>? bytes, CborObject? obj}) {
    final CborListValue cbor = CborSerializable.cborTagValue(
        cborBytes: bytes, object: obj, tags: CborTagsConst.address);
    final String address = cbor.elementAs(0);
    final BigInt balance = cbor.elementAs(1);
    final DateTime updated = cbor.elementAs(2);
    return ChainAccountBalance(
        address: address, network: network, balance: balance, updated: updated);
  }

  final String address;
  String get toAddress {
    return address;
  }

  final InternalStreamValue<IntegerBalance> balance;
  BigInt get currencyBalance => balance.value.balance;
  bool get hasBalance => balance.value.largerThanZero;
  DateTime _updated;
  DateTime get updated => _updated;

  CborTagValue toCbor() {
    return CborTagValue(
        CborSerializable.fromDynamic(
            [address, currencyBalance, CborEpochIntValue(updated)]),
        CborTagsConst.address);
  }
}

abstract final class BaseChainAccount<X, T extends TokenCore, N extends NFTCore,
    TRANSACTION extends ChainTransaction> with CborSerializable, Equatable {
  _WalletAddressStatus _status = _WalletAddressStatus.init;

  BaseChainAccount({
    required this.address,
    required this.keyIndex,
    required this.network,
    required this.networkAddress,
    required this.coin,
    required String? accountName,
    required this.identifier,
  }) : _accountName = accountName;
  // _WalletAddressStatus _status = _WalletAddressStatus.init;
  final ChainAccountBalance address;
  final AddressDerivationIndex keyIndex;
  final int network;
  String? get type;
  final X networkAddress;
  final CryptoCoins coin;
  String get baseAddress => address.toAddress;
  String get viewAddress => address.toAddress;
  List<int>? get publicKey;
  final String identifier;
  WalletAccountTransactions<TRANSACTION> _transaction =
      WalletAccountTransactions(transactions: []);
  List<TRANSACTION> get transactions => _transaction.transactions;
  List<N> _nfts = [];
  List<N> get nfts => _nfts;
  List<T> _tokens = [];
  List<T> get tokens => _tokens;
  String? _accountName;
  String? get accountName => _accountName;
  NewAccountParams toAccountParams();
  List<AddressDerivationIndex> accessKeysIndexes() {
    if (multiSigAccount) {
      throw WalletExceptionConst.featureUnavailableForMultiSignature;
    }
    return signerKeyIndexes();
  }

  List<AddressDerivationIndex> signerKeyIndexes() {
    if (multiSigAccount) {
      throw WalletExceptionConst.featureUnavailableForMultiSignature;
    }
    return [keyIndex];
  }

  IAdressType get iAddressType => IAdressType.singleKey;
  bool get multiSigAccount => iAddressType.isMultisig;
  Future<List<T>> _getTokens();
}

abstract final class ChainAccount<X, T extends TokenCore, N extends NFTCore,
        TRANSACTION extends ChainTransaction>
    extends BaseChainAccount<X, T, N, TRANSACTION>
    with
        ChainAccountRepository<X, T, N, TRANSACTION>,
        ChainAccountController<X, T, N, TRANSACTION> {
  ChainAccount(
      {required super.address,
      required super.keyIndex,
      required super.network,
      required super.networkAddress,
      required super.coin,
      required super.accountName,
      required super.identifier});

  C cast<C extends ChainAccount>() {
    if (this is C) return this as C;
    throw WalletExceptionConst.internalError("ChainAccount");
  }

  final OnceRunner<WalletAccountTransactions<TRANSACTION>> _transactionRunner =
      OnceRunner<WalletAccountTransactions<TRANSACTION>>();
  final OnceRunner<List<T>> _tokenRunner = OnceRunner<List<T>>();

  @override
  Future<List<T>> _getTokens() async {
    return _tokenRunner.get(
        onFetch: () async {
          final tokens = await _getTokensFromStorage();
          _tokens = tokens.immutable;
          for (final e in _tokens) {
            e.streamBalance._disposeCallback = () => false;
          }
          return _tokens;
        },
        onFetched: () => _tokens);
  }

  Future<WalletAccountTransactions<TRANSACTION>> _getTransactions() async {
    return _transactionRunner.get(
        onFetch: () async {
          final txes = await _getTransactionsFromStorage();
          _transaction = WalletAccountTransactions(transactions: txes);
          return _transaction;
        },
        onFetched: () => _transaction);
  }

  Future<void> _init() async {
    if (_status.isReady) return;
    _status = _WalletAddressStatus.ready;
    await _getTokens();
    final nfts = await _getNfts();
    await _getTransactions();
    _nfts = nfts.immutable;
  }

  @override
  String toString() {
    return address.address;
  }
}

base mixin ChainAccountController<X, T extends TokenCore, N extends NFTCore,
        TRANSACTION extends ChainTransaction>
    on
        BaseChainAccount<X, T, N, TRANSACTION>,
        ChainAccountRepository<X, T, N, TRANSACTION> {
  Future<T> _addToken(T newToken) async {
    if (_tokens.contains(newToken)) {
      throw WalletExceptionConst.tokenAlreadyExist;
    }
    final t = newToken.clone() as T;
    t.streamBalance._disposeCallback = () => false;
    _tokens = [t, ..._tokens].immutable;
    await _saveToken(token: newToken);
    return t;
  }

  Future<void> _addTx(TRANSACTION tx) async {
    _transaction.addTx(tx);
    await _saveTransaction(transaction: tx);
  }

  Future<void> _removeTx(TRANSACTION tx) async {
    _transaction.removeTx(tx);
    await _removeTransaction(transaction: tx);
  }

  Future<T?> _updateToken(Token updateToken, T token) async {
    if (await _removeToken(token)) {
      final t = token.updateToken(updateToken) as T;
      t.streamBalance._disposeCallback = () => false;
      _tokens = [t, ..._tokens].immutable;
      await _saveToken(token: token);
      return t;
    }
    return null;
  }

  Future<bool> _removeToken(T token) async {
    assert(tokens.contains(token), "token not found");
    if (!tokens.contains(token)) return false;
    final existTokens = _tokens.clone();
    final currentToken = existTokens.firstWhereOrNull((e) => e == token);
    assert(currentToken != null, "token not found.");
    if (currentToken == null) return false;
    existTokens.removeWhere((element) => element == currentToken);
    _tokens = existTokens.immutable;
    currentToken.streamBalance._disposeInternal();
    await _removeTokenFromStorage(token: token);
    return true;
  }

  Future<void> _addNFT(N newNft) async {
    if (_nfts.contains(newNft)) {
      throw WalletExceptionConst.nftsAlreadyExist;
    }
    _nfts = List.unmodifiable([newNft, ..._nfts]);
    await _saveNFT(nft: newNft);
  }

  Future<void> _removeNFT(N nft) async {
    if (!_nfts.contains(nft)) return;
    final existNfts = List.from(_nfts);
    existNfts.removeWhere((element) => element == nft);
    _nfts = List.unmodifiable(_nfts);
    await _removeNFTFromStorage(nft: nft);
  }

  Future<bool> _updateTokenBalance(
      T token, _ONUUPDATETOKENBALANCE onUpdateBalance) async {
    bool save = onUpdateBalance();
    final tokens = await _getTokens();
    final addressToken = tokens.firstWhereNullable((e) => e == token);
    if (addressToken == null) return false;
    if (!identical(token, addressToken)) {
      save = addressToken.streamBalance.value
          ._internalUpdateBalance(token.streamBalance.value.balance);
    }
    if (save) {
      await _saveToken(token: token);
    }
    return save;
  }

  Future<bool> _updateAddressBalance([BigInt? updateBalance]) async {
    if (address.balance.value._internalUpdateBalance(updateBalance)) {
      address.balance.notify();
      await _saveAddress();
      return true;
    }
    return false;
  }

  Future<void> _setAccountName(String? name) async {
    if (name == _accountName) return;
    _accountName = name;
    await _saveAddress();
  }
}
base mixin ChainAccountRepository<X, T extends TokenCore, N extends NFTCore,
        TRANSACTION extends ChainTransaction>
    on BaseChainAccount<X, T, N, TRANSACTION> {
  NetworkStorageManager? _networkStorage;
  NetworkStorageManager get _storage {
    appLogger.error(
      runtime: runtimeType,
      functionName: "_storage",
      msg: "storage not initialized: $network $_networkStorage $hashCode",
      when: () => _networkStorage == null,
    );
    return _networkStorage!;
  }

  void _setStorage(NetworkStorageManager storage) {
    _networkStorage = storage;
  }

  Future<List<T>> _getTokensFromStorage(
      {int? offset,
      int? limit,
      IDatabaseQueryOrdering ordering = IDatabaseQueryOrdering.desc}) async {
    final storagekey = DefaultNetworkStorageId.token;
    final data = await _storage.queriesNetworkStorage(
        address: this,
        storage: storagekey,
        limit: limit,
        offset: offset,
        ordering: ordering);
    final tokens = data
        .map((e) => TokenCore.deserialize<T>(bytes: e))
        .toList()
        .whereType<T>()
        .toList();
    appLogger.debug(
        when: () => tokens.isNotEmpty,
        runtime: runtimeType,
        functionName: "_getTokens",
        msg: "$viewAddress ${tokens.length} tokens founds.");
    assert(tokens.length == data.length, "some token deserialization failed.");
    return tokens;
  }

  Future<void> _saveToken({required T token}) async {
    final storageKey = DefaultNetworkStorageId.token;
    if (!tokens.contains(token)) {
      return;
    }
    await _storage.insertNetworkStorage(
        address: this,
        storage: storageKey,
        value: token,
        keyA: token.identifier);
  }

  Future<void> _removeTokenFromStorage({required T token}) async {
    final storageKey = DefaultNetworkStorageId.token;
    await _storage.removeNetworkStorage(
        address: this, storage: storageKey, keyA: token.identifier);
  }

  Future<List<N>> _getNfts(
      {int? offset,
      int? limit,
      IDatabaseQueryOrdering ordering = IDatabaseQueryOrdering.desc}) async {
    final storagekey = DefaultNetworkStorageId.nft;
    final data = await _storage.queriesNetworkStorage(
        address: this,
        storage: storagekey,
        limit: limit,
        offset: offset,
        ordering: ordering);
    final nfts = data
        .map((e) =>
            MethodUtils.nullOnException(() => NFTCore.deserialize<N>(bytes: e)))
        .toList()
        .whereType<N>()
        .toList();
    appLogger.debug(
        when: () => nfts.isNotEmpty,
        runtime: runtimeType,
        functionName: "_getNfts",
        msg: "$viewAddress ${nfts.length} founds.");
    assert(nfts.length == data.length, "some nft deserialization failed.");
    return nfts;
  }

  Future<void> _saveNFT({required N nft}) async {
    final storagekey = DefaultNetworkStorageId.nft;
    assert(nfts.contains(nft), 'asset not found an account');
    if (!nfts.contains(nft)) {
      return;
    }
    await _storage.insertNetworkStorage(
        address: this, storage: storagekey, value: nft, keyA: nft.identifier);
  }

  Future<void> _removeNFTFromStorage({required N nft}) async {
    final storagekey = DefaultNetworkStorageId.nft;
    await _storage.removeNetworkStorage(
        address: this, storage: storagekey, keyA: nft.identifier);
  }

  Future<List<TRANSACTION>> _getTransactionsFromStorage() async {
    final storagekey = DefaultNetworkStorageId.transaction;
    final data = await _storage.queriesNetworkStorage(
        address: this,
        storage: storagekey,
        limit: NetworkStorageManager.maxAddressItemLimit);
    final txes = data
        .map((e) => MethodUtils.nullOnException(() =>
            ChainTransaction.deserialize<TRANSACTION>(_storage.network,
                bytes: e)))
        .toList()
        .whereType<TRANSACTION>()
        .toList();
    appLogger.debug(
        when: () => txes.isNotEmpty,
        runtime: runtimeType,
        functionName: "_getTransactions",
        msg: "$viewAddress ${txes.length} founds.");
    assert(
        txes.length == data.length, "some transaction deserialization failed.");
    return txes;
  }

  Future<void> _saveTransaction({required TRANSACTION transaction}) async {
    final storagekey = DefaultNetworkStorageId.transaction;
    await _storage.insertNetworkStorage(
        address: this,
        storage: storagekey,
        value: transaction,
        keyA: transaction.storageIdentifier,
        createdAt: transaction.time);
  }

  Future<void> _removeTransaction({required TRANSACTION transaction}) async {
    final storagekey = DefaultNetworkStorageId.transaction;
    await _storage.removeNetworkStorage(
        address: this,
        storage: storagekey,
        keyA: transaction.storageIdentifier);
  }

  Future<void> _saveAddress() async {
    final storagekey = DefaultNetworkStorageId.address;
    await _storage.insertNetworkStorage(
        address: this, storage: storagekey, value: this);
  }

  Future<void> _removeAddress() async {
    final storagekey = DefaultNetworkStorageId.address;
    final storage = _storage;
    _networkStorage = null;
    await storage.removeNetworkStorage(address: this, storage: storagekey);
    await storage.removeNetworkStorage(address: this);
  }
}
